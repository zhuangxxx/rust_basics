# Rust Basics

Rust 基础知识及代码实现

## Rust Algorithms

Rust 算法与数据结构

参考:

- [The Algorithms](https://the-algorithms.com/language/rust)
- [谁教你这么剪的 | 11大排序的原理讲解和Python源码剖析](https://www.bilibili.com/video/BV1Zs4y1X7mN)

### 排序算法 (Sorting Algorithm)

|         算法名称         |    平均时间复杂度    | 最好情况时间复杂度 |  最坏情况时间复杂度  |   空间复杂度    | 是否稳定 |                                说明                                |
| ------------------------ | ------------------ | ---------------- | ------------------ | ------------- | -------- | ------------------------------------------------------------------ |
| 冒泡排序(Bubble Sort)    | $O(n^2)$           | $O(n)$           | $O(n^2)$           | $O(1)$        | 稳定     | 序列有序时为最好情况                                                 |
| 选择排序(Selection Sort) | $O(n^2)$           | $O(n^2)$         | $O(n^2)$           | $O(1)$        | 不稳定   |                                                                    |
| 插入排序(Insertion Sort) | $O(n^2)$           | $O(n)$           | $O(n^2)$           | $O(1)$        | 稳定     | 序列有序时为最好情况                                                 |
| 希尔排序(Shell Sort)     | $O(n^{\frac 3 2})$ | $O(n)$           | $O(n^{\frac 3 2})$ | $O(1)$        | 不稳定   | 时间复杂度与增量有关<br/>$O(n^{\frac 3 2})$为使用Knuth增量时时间复杂度 |
| 归并排序(Merge Sort)     | $O(n\log_2 n)$     | $O(n\log_2 n)$   | $O(n\log_2 n)$     | $O(n)$        | 稳定     |                                                                    |
| 快速排序(Quick Sort)     | $O(n\log_2 n)$     | $O(n\log_2 n)$   | $O(n^2)$           | $O(\log_2 n)$ | 不稳定   | 序列有序时为最坏情况<br/>随机轴分区可规避最坏情况，但平均效率降低        |
| 堆排序(Heap Sort)        | $O(n\log_2 n)$     | $O(n\log_2 n)$   | $O(n\log_2 n)$     | $O(1)$        | 不稳定   |                                                                    |

## Rust Design Patterns

Rust 设计模式

参考:

- [Dive Into DESIGN PATTERNS](https://refactoringguru.cn/design-patterns/catalog)

### 工厂方法 (Factory Method)

**工厂方法模式**是一种创建型设计模式，其在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。

#### 结构

![工厂方法模式](static/factory-method.png)

#### 应用场景

- 当你在编写代码的过程中，如果无法预知对象确切类别及其依赖关系时，可使用工厂方法。
- 如果你希望用户能扩展你软件库或框架的内部组件，可使用工厂方法。
- 如果你希望复用现有对象来节省系统资源，而不是每次都重新创建对象，可使用工厂方法。

#### 解决问题

- 可以避免创建者和具体产品之间的紧密耦合。
- *单一职责原则*。你可以将产品创建代码放在程序的单一位置，从而使得代码更容易维护。
- *开闭原则*。无需更改现有客户端代码，你就可以在程序中引入新的产品类型。

#### 局限

- 应用工厂方法模式需要引入许多新的子类，代码可能会因此变得更复杂。最好的情况是将该模式引入创建者类的现有层次结构中。

### 抽象工厂 (Abstract Factory)

**抽象工厂模式**是一种创建型设计模式，它能创建一系列相关的对象，而无需指定其具体类。

#### 结构

![抽象工厂模式](static/abstract-factory.png)

#### 应用场景

- 如果代码需要与多个不同系列的相关产品交互，但是由于无法提前获取相关信息，或者出于对未来扩展性的考虑，你不希望代码基于产品的具体类进行构建，在这种情况下，你可以使用抽象工厂。
- 如果你有一个基于一组**抽象方法**的类，且其主要功能因此变得不明确，那么在这种情况下可以考虑使用抽象工厂模式。

#### 解决问题

- 你可以确保同一工厂生成的产品相互匹配。
- 你可以避免客户端和具体产品代码的耦合。
- *单一职责原则*。你可以将产品生成代码抽取到同一位置，使得代码易于维护。
- *开闭原则*。向应用程序中引入新产品变体时，你无需修改客户端代码。

#### 局限

- 由于采用该模式需要向应用中引入众多接口和类，代码可能会比之前更加复杂。

### 生成器模式 (Builder)

**生成器模式**是一种创建型设计模式，使你能够分步骤创建复杂对象。该模式允许你使用相同的创建代码生成不同类型和形式的对象。

#### 结构

![生成器模式](static/builder.png)

#### 应用场景

- 使用生成器模式可避免 “重叠构造函数 （telescoping constructor）” 的出现。
- 当你希望使用代码创建不同形式的产品 （例如石头或木头房屋） 时，可使用生成器模式。
- 使用生成器构造**组合**树或其他复杂对象。

#### 解决问题

- 你可以分步创建对象，暂缓创建步骤或递归运行创建步骤。
- 生成不同形式的产品时，你可以复用相同的制造代码。
- *单一职责原则*。你可以将复杂构造代码从产品的业务逻辑中分离出来。

#### 局限

- 由于该模式需要新增多个类，因此代码整体复杂程度会有所增加。

### 原型模式 (Prototype)

**原型模式**是一种创建型设计模式，使你能够复制已有对象，而又无需使代码依赖它们所属的类。

#### 结构

![原型模式](static/prototype.png)

#### 应用场景

- 如果你需要复制一些对象，同时又希望代码独立于这些对象所属的具体类，可以使用原型模式。
- 如果子类的区别仅在于其对象的初始化方式，那么你可以使用该模式来减少子类的数量。别人创建这些子类的目的可能是为了创建特定类型的对象。

#### 解决问题

- 你可以克隆对象，而无需与它们所属的具体类相耦合。
- 你可以克隆预生成原型，避免反复运行初始化代码。
- 你可以更方便地生成复杂对象。
- 你可以用继承以外的方式来处理复杂对象的不同配置。

#### 局限

- 克隆包含循环引用的复杂对象可能会非常麻烦。

### 单例模式 (Singleton)

**单例模式**是一种创建型设计模式，让你能够保证一个类只有一个实例，并提供一个访问该实例的全局节点。

#### 结构

![单例模式](static/singleton.png)

#### 应用场景

- 如果程序中的某个类对于所有客户端只有一个可用的实例，可以使用单例模式。
- 如果你需要更加严格地控制全局变量，可以使用单例模式。

#### 解决问题

- 你可以保证一个类只有一个实例。
- 你获得了一个指向该实例的全局访问节点。
- 仅在首次请求单例对象时对其进行初始化。

#### 局限

- 违反了*单一职责原则*。该模式同时解决了两个问题。
- 单例模式可能掩盖不良设计，比如程序各组件之间相互了解过多等。
- 该模式在多线程环境下需要进行特殊处理，避免多个线程多次创建单例对象。
- 单例的客户端代码单元测试可能会比较困难，因为许多测试框架以基于继承的方式创建模拟对象。由于单例类的构造函数是私有的，而且绝大部分语言无法重写静态方法，所以你需要想出仔细考虑模拟单例的方法。要么干脆不编写测试代码，或者不使用单例模式。

